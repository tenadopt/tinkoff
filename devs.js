function devs () {
    // accumulator for enter data type string
    let userInput = ''
    process.stdin.on('data', (data) => {
        userInput += data.toString()
    })
    process.stdin.on('end', () => {
        let newArr = []
        const lines = userInput.split("\n")
        let dn = Number(lines[0])
        for (let i = 1; i <= dn*2; i += 2) {
            let aStr = strToNumArr(lines[i + 1])
            newArr.push(aStr)
        }
        return newArr.forEach((dataSet)=>checkFreeCon(dataSet))
    })
}

function strToNumArr(str) {
    return  str.split('').map(el=>Number(el))
}

function checkFreeCon(dataSet) {
    //exit when we can't connect to dev
    const sortArr = dataSet.sort()
    let firstNC = sortArr[0]
    let conFor = sortArr[1]
    if (firstNC>1) {
        console.log(firstNC)
        return console.log("Yes")
    } else if (conFor == 0) {
        return console.log("Yes")
    } else if (firstNC === 0 && conFor === 0) {
        return console.log("No")
    }
    getNextCon(sortArr, firstNC)
    return console.log("Yes")
}



function getNextCon(arr, conFor) {
    arr[0] = 10
}

devs()



// Тинькофф начал разрабатывать новый проект. Для этого было подобрано ﻿
// �
// n﻿ разработчиков. У ﻿
// �
// i﻿-го разработчика есть порог социальности ﻿
// �
// �
// a
// i
// ​
// ﻿, это значит, что он готов контактировать напрямую с не более чем ﻿
// �
// �
// a
// i
// ​
// ﻿ другими разработчиками.
//
//     Определите, можно ли наладить контакт между какими-то парами разработчиков, так чтобы любые два контактировали либо напрямую, либо через других разработчиков.
//
//     Формат входных данных
//
// Каждый тест состоит из нескольких наборов входных данных.
//
//     В первой строке находится одно целое число ﻿
// �
// t﻿ ﻿
// (
//     1
// ≤
// �
// ≤
// 1000
// )
// (1≤t≤1000)﻿ — количество наборов входных данных. Далее следует описание наборов входных данных.
//
//     Первая строка каждого набора входных данных содержит одно число ﻿
// �
// n﻿ ﻿
// (
//     1
// ≤
// �
// ≤
// 1
// 0
// 5
// )
// (1≤n≤10
// 5
// )﻿ — количество разработчиков. Вторая строка содержит ﻿
// �
// n﻿ натуральных чисел ﻿
// �
// �
// a
// i
// ​
// ﻿ ﻿
// (
//     1
// ≤
// �
// �
// ≤
// 1
// 0
// 9
// )
// (1≤a
// i
// ​
// ≤10
// 9
// )﻿ — пороги социальностей разработчиков. Гарантируется, что сумма значений ﻿
// �
// n﻿ по всем наборам входных данных не превосходит ﻿
// 1
// 0
// 5
// 10
// 5
//  ﻿.
//
// Формат выходных данных
//
// Для каждого набора входных данных, выведите «﻿
// �
// �
// �
// Yes﻿», если можно наладить контакт между программистами, и «﻿
// �
// �
// No﻿» иначе. Вы можете выводить каждую букву в любом регистре (строчную или заглавную). Например, строки «﻿
// �
// �
// �
// yEs﻿», «﻿
// �
// �
// �
// yes﻿», «﻿
// �
// �
// �
// Yes﻿» и «﻿
// �
// �
// �
// YES﻿» будут приняты как положительный ответ.
//
//     Примеры данных
// 4
// 1
// 1000000000
// 2
// 1 1
// 3
// 1 1 1
// 4
// 1 1 2 2
// 4
// 1
// 1000000000
// 2
// 1 1
// 3
// 1 1 1
// 4
// 1 1 2 2
// Yes
// Yes
// No
// Yes


// 3 задание
// Ограничение времени
// 1 секунда
// Ограничение памяти
// 256 МБ
// Максим пришёл в Тинькофф, чтобы взять кредит на покупку новогодних подарков. Ему предодобрен кредит в размере ﻿
// �
// m﻿ бурлей, значит он может взять любое целое количество бурлей от ﻿
// 0
// 0﻿ до ﻿
// �
// m﻿ включительно.
//
//     У Максима есть заранее подготовленный список из ﻿
// �
// n﻿ подарков. Он планирует идти по порядку вдоль списка и каждый раз, когда он видит подарок, на который у него хватает денег, он обязательно моментально его покупает.
//
//     Помогите ему посчитать, какое максимальное количество денег у него может остаться после закупки подарков, если он возьмёт кредит оптимального размера (то есть такого, чтобы у него осталось как можно больше денег после покупки подарков по алгоритму).
//
// Формат входных данных
//
// Первая строка содержит два целых числа ﻿
// �
// n﻿ и ﻿
// �
// m﻿ ﻿
// (
//     1
// ≤
// �
// ≤
// 1
// 0
// 5
//     ,
//     1
// ≤
// �
// ≤
// 1
// 0
// 9
// )
// (1≤n≤10
// 5
//     ,1≤m≤10
// 9
// )﻿ — длина списка подарков и размер предодобренного кредита.
//
//     Вторая строка содержит ﻿
// �
// n﻿ целых чисел — цены подарков ﻿
// �
// �
// a
// i
// ​
// ﻿ ﻿
// (
//     1
// ≤
// �
// �
// ≤
// 1
// 0
// 9
// )
// (1≤a
// i
// ​
// ≤10
// 9
// )﻿.
//
// Формат выходных данных
//
// Выведите одно число — максимальное количество бурлей, которое могло остаться у Максима после закупки подарков.
//
//     Замечание
//
// В первом примере Максим может взять в кредит ﻿
// 3
// 3﻿ бурля, и тогда он купит только последний подарок. Во втором примере Максим может взять кредит на все ﻿
// 10
// 10﻿ бурлей и купить все подарки.
//
//     Примеры данных
// Пример 1
// 3 10
// 5 4 1
// 3 10
// 5 4 1
// 2
// 2
// Пример 2
// 3 10
// 1 2 3
// 3 10
// 1 2 3
// 4


// 4 задание
// Ограничение времени
// 1 секунда
// Ограничение памяти
// 256 МБ
// Боб начинает свой путь в Тинькофф Инвестициях. Сейчас его интересуют k компаний, и он обязательно хочет купить акции всех этих компаний, чтобы у каждой компании была хотя бы одна акция.
//
//     Тинькофф Инвестиции предложили ему корневое дерево из ﻿
// �
// n﻿ вершин, в каждой из которых лежит пакет акций какой-то из интересующих его компаний, также задана стоимость каждого пакета. Вершины корневого дерева пронумерованы целыми числами от ﻿
// 1
// 1﻿ до ﻿
// �
// n﻿.
//
//     Функционал нынешнего приложения позволяет Бобу купить поддерево этого дерева, на это он потратит столько денег, сколько суммарно стоят пакеты в поддереве и получит все акции из этого поддерева. В результате покупки Боб хочет, чтобы у него были акции всех интересующих его компаний. Поскольку Боб ещё студент, он хочет потратить минимальное количество денег.
//
//     Определите может ли Боб выкупить какое-то поддерево так, чтобы у него оказались все нужные ему акции, и если да, то какое минимальное количество денег он для этого должен потратить.
//
//     Формат входных данных
//
// В первой строке заданы два целых числа ﻿
// �
// n﻿, ﻿
// �
// k﻿ ﻿
// (
//     1
// ≤
// �
// ≤
// 3
// ⋅
// 1
// 0
// 5
//     ,
//     1
// ≤
// �
// ≤
// 30
// )
// (1≤n≤3⋅10
// 5
//     ,1≤k≤30)﻿ — размер дерева и количество интересных для Боба компаний.
//
//     Следующие ﻿
// �
// k﻿ строк содержат различные строки длиной не более ﻿
// 10
// 10﻿ символов из маленьких латинских букв — названия компаний.
//
//     Следующие ﻿
// �
// n﻿ строк содержат описание дерева. В ﻿
// �
// i﻿-ой строке находится описание ﻿
// �
// i﻿-й вершины дерева ﻿
// �
// �
// p
// i
// ​
// ﻿, ﻿
// �
// �
// a
// i
// ​
// ﻿, ﻿
// �
// �
// c
// i
// ​
// ﻿ ﻿
// (
//     0
// ≤
// �
// �
// ≤
// �
// ,
// 0
// ≤
// �
// �
// ≤
// 1
// 0
// 4
// )
// (0≤p
// i
// ​
// ≤n,0≤a
// i
// ​
// ≤10
// 4
// )﻿:
//
// ﻿
// �
// �
// p
// i
// ​
// ﻿ — номер родителя ﻿
// �
// i﻿-ой вершины или ﻿
// 0
// 0﻿, если вершина является корнем
// ﻿
// �
// �
// a
// i
// ​
// ﻿ — стоимость пакета акций в ﻿
// �
// i﻿-ой вершине
// ﻿
// �
// �
// c
// i
// ​
// ﻿ — название компании, пакет акции которой лежит в ﻿
// �
// i﻿-ой вершине
// Гарантируется, что компании, акции которых лежат в вершинах, интересуют Боба. Гарантируется, что входные данные задают корректное корневое дерево.
//
//     Формат выходных данных
//
// Выведите единственное число — минимальное количество денег, которое должен потратить Боб, или ﻿
// −
// 1
// −1﻿, если выкупить акции всех компаний невозможно.
//
//     Замечание
//
// Определение корневого дерева можете посмотреть в Википедии.
//
//     Примеры данных
// 5 2
// A
// B
// 0 1 A
// 1 2 A
// 1 2 B
// 1 1 B
// 4 2 A
// 5 2
// A
// B
// 0 1 A
// 1 2 A
// 1 2 B
// 1 1 B
// 4 2 A
// 3

//
// 5 задание
// Ограничение времени
// 2 секунды
// Ограничение памяти
// 256 МБ
// Дети из кружка Тинькофф Поколение любят считать манулов в различных чатиках. В этой задаче вам тоже придётся считать манулов.
//
//     Всего есть ﻿
// �
// n﻿ детей, некоторые из которых дружат друг с другом. Формально, заданы ﻿
// �
// m﻿ различных неупорядоченных пар ﻿
// (
// �
// ,
// �
// )
// (v,u)﻿, таких что ребёнок с номером ﻿
// �
// v﻿ дружит с ребёнком ﻿
// �
// u﻿.
//
//     Изначально, ﻿
// �
// i﻿-ый ребёнок уже досчитал до ﻿
// �
// �
// a
// i
// ​
// ﻿ манулов. Далее происходят ﻿
// �
// q﻿ событий, каждое из которых имеет один из двух видов ﻿
// (
//     1
// ≤
// �
// ≤
// �
// ,
// 0
// ≤
// �
// ≤
// 1
// 0
// 4
// )
// (1≤v≤n,0≤x≤10
// 4
// )﻿:
//
// ﻿
// +
//     +﻿ ﻿
// �
// v﻿ ﻿
// �
// x﻿ — ребёнок с номером ﻿
// �
// v﻿ отправляет по ﻿
// �
// x﻿ стикеров с манулом каждому из своих друзей. Каждый из его друзей сразу же считает этих полученных манулов, т.е. прибавляет к своим уже посчитанным
// ﻿
// ?
//         ?﻿ ﻿
// �
// v﻿ — мы просим вас посчитать, сколько манулов на данный момент уже посчитал ребёнок с номером ﻿
// �
// v﻿
// Формат входных данных
//
// В первой строке даны три числа ﻿
// �
// n﻿, ﻿
// �
// m﻿ и ﻿
// �
// q﻿ ﻿
// (
//     1
// ≤
// �
// ≤
// 1
// 0
// 5
//     ,
//     0
// ≤
// �
// ≤
// 1
// 0
// 5
//     ,
//     1
// ≤
// �
// ≤
// 3
// ⋅
// 1
// 0
// 5
// )
// (1≤n≤10
// 5
//     ,0≤m≤10
// 5
//     ,1≤q≤3⋅10
// 5
// )﻿.
//
// Во второй строке заданы ﻿
// �
// n﻿ чисел ﻿
// �
// �
// a
// i
// ​
// ﻿ ﻿
// (
//     0
// ≤
// �
// �
// ≤
// 1
// 0
// 9
// )
// (0≤a
// i
// ​
// ≤10
// 9
// )﻿ — количество уже посчитанных манулов у ﻿
// �
// i﻿-го ребёнка.
//
//     В каждой из следующих ﻿
// �
// m﻿ строк заданы два числа ﻿
// �
// v﻿, ﻿
// �
// u﻿ ﻿
// (
//     1
// ≤
// �
// ≠
// �
// ≤
// �
// )
// (1≤v
// 
// ​
//  =u≤n)﻿ — пары друзей. Гарантируется, что пары не повторяются.
//
//     В каждой из следующих ﻿
// �
// q﻿ строк описаны события в описанном формате. Гарантируется, что будет хотя бы одно событие типа ﻿
// ?
//         ?﻿.
//
// Формат выходных данных
//
// Для каждого события типа ﻿
// ?
//         ?﻿ выведите в отдельной строке требуемое значение.
//
//     Примеры данных
// 5 5 5
// 1 2 3 4 5
// 1 2
// 2 3
// 3 4
// 4 5
// 5 1
//     ? 1
//         ? 5
//         + 1 2
//             ? 1
//                 ? 5
//                 5 5 5
// 1 2 3 4 5
// 1 2
// 2 3
// 3 4
// 4 5
// 5 1
//     ? 1
//         ? 5
//         + 1 2
//             ? 1
//                 ? 5
//                 1
//             5
//     1
// 7


// 6 задание
// Ограничение времени
// 3 секунды
// Ограничение памяти
// 256 МБ
// Поздравляю, вы дошли до серьёзной задачи, больше никаких легенд, только хардкор.
//
//     Дан массив ﻿
// �
// a﻿ из ﻿
// �
// n﻿ целых чисел. Требуется выполнить ﻿
// �
// q﻿ запросов такого вида ﻿
// (
//     1
// ≤
// �
// ≤
// �
// ≤
// �
// ,
// 0
// ≤
// �
// ,
// �
// ,
// �
// ≤
// 1
// 0
// 9
// )
// (1≤l≤r≤n,0≤k,b,x≤10
// 9
// )﻿:
//
// ﻿
// +
//     +﻿ ﻿
// �
// l﻿ ﻿
// �
// r﻿ ﻿
// �
// x﻿ — прибавить ﻿
// �
// x﻿ ко всем ﻿
// �
// �
// a
// i
// ​
// ﻿ на отрезке ﻿
// �
// ∈
// [
// �
// ,
// �
// ]
// i∈[l,r]﻿
// ﻿
// ?
//         ?﻿ ﻿
// �
// l﻿ ﻿
// �
// r﻿ ﻿
// �
// k﻿ ﻿
// �
// b﻿ — вывести ﻿
// �
// �
// �
// �
// ≤
// �
// ≤
// �
// �
// �
// �
// (
// �
// �
// ,
// �
// ⋅
// �
// +
// �
// )
// max
// l≤i≤r
// ​
//  min(a
// i
// ​
// ,k⋅i+b)﻿
// Формат входных данных
//
// В первой строке заданы два числа ﻿
// �
// n﻿, ﻿
// �
// q﻿ ﻿
// (
//     1
// ≤
// �
// ≤
// 2
// ⋅
// 1
// 0
// 5
//     ,
//     1
// ≤
// �
// ≤
// 5
// ⋅
// 1
// 0
// 5
// )
// (1≤n≤2⋅10
// 5
//     ,1≤q≤5⋅10
// 5
// )﻿.
//
// Во второй строке задан массив ﻿
// �
// a﻿ ﻿
// (
//     0
// ≤
// �
// �
// ≤
// 1
// 0
// 9
// )
// (0≤a
// i
// ​
// ≤10
// 9
// )﻿.
//
// Следующие ﻿
// �
// q﻿ строк содержат запросы в заданном формате. Гарантируется, что будет хотя бы один запрос типа ﻿
// ?
//         ?﻿.
//
// Формат выходных данных
//
// Для каждого запроса типа ﻿
// ?
//         ?﻿ выведите ответ в отдельной строке.
//
//     Примеры данных
// 6 3
// 2 4 6 8 10 12
//     ? 2 5 3 0
// + 2 3 6
//     ? 2 5 3 2
// 6 3
// 2 4 6 8 10 12
//     ? 2 5 3 0
// + 2 3 6
//     ? 2 5 3 2
// 10
// 11
